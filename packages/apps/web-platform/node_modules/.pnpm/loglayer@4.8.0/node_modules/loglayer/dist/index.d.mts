declare enum LogLevel {
    info = "info",
    warn = "warn",
    error = "error",
    debug = "debug",
    trace = "trace",
    fatal = "fatal"
}
/**
 * Specifies the type of logging library used.
 */
declare enum LoggerType {
    BUNYAN = "bunyan",
    CONSOLA = "consola",
    CONSOLE = "console",
    ELECTRON_LOG = "electronLog",
    LOG4JS_NODE = "log4js-node",
    PINO = "pino",
    ROARR = "roarr",
    SIGNALE = "signale",
    WINSTON = "winston",
    OTHER = "other",
    DATADOG_BROWSER_LOGS = "datadog-browser"
}
type MessageDataType = string | number | null | undefined;
type ErrorDataType = any;

interface PluginBeforeDataOutParams {
    /**
     * Log level of the data
     */
    logLevel: LogLevel;
    /**
     * The object containing metadata / context / error data. This
     * is `undefined` if there is no object with data.
     */
    data?: Record<string, any>;
}
type PluginBeforeDataOutFn = (params: PluginBeforeDataOutParams) => Record<string, any> | null | undefined;
interface PluginShouldSendToLoggerParams {
    /**
     * Message data that is copied from the original.
     */
    messages: any[];
    /**
     * Log level of the message
     */
    logLevel: LogLevel;
    /**
     * The object containing metadata / context / error data. This
     * is `undefined` if there is no object with data.
     */
    data?: Record<string, any>;
}
type PluginShouldSendToLoggerFn = (params: PluginShouldSendToLoggerParams) => boolean;
interface PluginBeforeMessageOutParams {
    /**
     * Log level of the message
     */
    logLevel: LogLevel;
    /**
     * Message data that is copied from the original.
     */
    messages: any[];
}
type PluginBeforeMessageOutFn = (params: PluginBeforeMessageOutParams) => any[];
type PluginOnMetadataCalledFn = (metadata: Record<string, any>) => Record<string, any> | null | undefined;
interface LogLayerPlugin {
    /**
     * Unique identifier for the plugin. Used for selectively disabling / enabling
     * and removing the plugin.
     */
    id?: string;
    /**
     * If true, the plugin will skip execution
     */
    disabled?: boolean;
    /**
     * Called after the assembly of the data object that contains
     * the metadata / context / error data before being sent to the destination logging
     * library.
     *
     * - The shape of `data` varies depending on your `fieldName` configuration
     * for metadata / context / error. The metadata / context / error data is a *shallow* clone.
     * - If data was not found for assembly, `undefined` is used as the `data` input.
     * - You can also create your own object and return it to be sent to the logging library.
     *
     * @returns [Object] The object to be sent to the destination logging
     * library or null / undefined to not pass an object through.
     */
    onBeforeDataOut?(params: PluginBeforeDataOutParams): Record<string, any> | null | undefined;
    /**
     * Called after `onBeforeDataOut` and before `shouldSendToLogger`.
     * This allows you to modify the message data before it is sent to the destination logging library.
     *
     * @returns [Array] The message data to be sent to the destination logging library.
     */
    onBeforeMessageOut?(params: PluginBeforeMessageOutParams): any[];
    /**
     * Called before the data is sent to the logger. Return false to omit sending
     * to the logger. Useful for isolating specific log messages for debugging /
     * troubleshooting.
     *
     * If there are multiple plugins with shouldSendToLogger defined, the
     * first plugin to return false will stop the data from being sent to the
     * logger.
     *
     * @returns boolean If true, sends data to the logger, if false does not.
     */
    shouldSendToLogger?(params: PluginShouldSendToLoggerParams): boolean;
    /**
     * Called when withMetadata() or metadataOnly() is called. This allows you to modify the metadata before it is sent to the destination logging library.
     *
     * The metadata is a *shallow* clone of the metadata input.
     *
     * If null is returned, then no metadata will be sent to the destination logging library.
     *
     * In multiple plugins, the modified metadata will be passed through each plugin in the order they are added.
     *
     * @returns [Object] The metadata object to be sent to the destination logging library.
     */
    onMetadataCalled?: (metadata: Record<string, any>) => Record<string, any> | null | undefined;
}
/**
 * List of plugin callbacks that can be called by the plugin manager.
 */
declare enum PluginCallbackType {
    onBeforeDataOut = "onBeforeDataOut",
    shouldSendToLogger = "shouldSendToLogger",
    onMetadataCalled = "onMetadataCalled",
    onBeforeMessageOut = "onBeforeMessageOut"
}

/**
 * Logging methods that are common to logging libraries
 */
interface LoggerLibrary {
    info(...data: any[]): void;
    warn(...data: any[]): void;
    error(...data: any[]): void;
    trace?: (...data: any[]) => void;
    debug(...data: any[]): void;
    fatal?: (...data: any[]) => void;
}
interface ILogBuilder<ErrorType = ErrorDataType> {
    /**
     * Sends a log message to the logging library under an info log level.
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    info(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the warn log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    warn(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the error log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    error(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the debug log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    debug(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the trace log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    trace(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the fatal log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    fatal(...messages: MessageDataType[]): void;
    /**
     * Specifies metadata to include with the log message
     */
    withMetadata(metadata: Record<string, any>): ILogBuilder<ErrorType>;
    /**
     * Specifies an Error to include with the log message
     */
    withError(error: ErrorType): ILogBuilder<ErrorType>;
    /**
     * Enable sending logs to the logging library.
     */
    enableLogging(): ILogBuilder<ErrorType>;
    /**
     * All logging inputs are dropped and stops sending logs to the logging library.
     */
    disableLogging(): ILogBuilder<ErrorType>;
}
interface ILogLayer<ExternalLogger extends LoggerLibrary = LoggerLibrary, ErrorType = ErrorDataType> extends ILogBuilder {
    /**
     * Calls child() and sets the prefix to be included with every log message.
     */
    withPrefix(string: string): ILogLayer<ExternalLogger, ErrorType>;
    /**
     * Appends context data which will be included with
     * every log entry.
     */
    withContext(context: Record<string, any>): ILogLayer<ExternalLogger, ErrorType>;
    /**
     * Specifies metadata to include with the log message
     */
    withMetadata(metadata: Record<string, any>): ILogBuilder;
    /**
     * Specifies an Error to include with the log message
     */
    withError(error: ErrorType): ILogBuilder;
    /**
     * Logs only the error object without a log message
     */
    errorOnly(error: ErrorType, opts?: ErrorOnlyOpts): void;
    /**
     * Logs only metadata without a log message
     */
    metadataOnly(metadata: Record<string, any>, logLevel: LogLevel): void;
    /**
     * Returns the underlying log instance
     */
    getLoggerInstance(): ExternalLogger;
    /**
     * Returns the context used for the logger
     */
    getContext(): Record<string, any>;
    /**
     * Creates a new instance of LogLayer but with the initialization
     * configuration and context data copied over.
     *
     * The copied context data is a *shallow copy*.
     */
    child(): ILogLayer<ExternalLogger, ErrorType>;
    /**
     * Disables inclusion of context data in the print
     */
    muteContext(): ILogLayer<ExternalLogger, ErrorType>;
    /**
     * Enables inclusion of context data in the print
     */
    unMuteContext(): ILogLayer<ExternalLogger, ErrorType>;
    /**
     * Disables inclusion of metadata data in the print
     */
    muteMetadata(): ILogLayer<ExternalLogger, ErrorType>;
    /**
     * Enables inclusion of metadata data in the print
     */
    unMuteMetadata(): ILogLayer<ExternalLogger, ErrorType>;
    /**
     * Enable sending logs to the logging library.
     */
    enableLogging(): ILogLayer<ExternalLogger, ErrorType>;
    /**
     * All logging inputs are dropped and stops sending logs to the logging library.
     */
    disableLogging(): ILogLayer<ExternalLogger, ErrorType>;
}
type ErrorSerializerType<ErrorType> = (err: ErrorType) => Record<string, any> | string;
interface ErrorOnlyOpts {
    /**
     * Sets the log level of the error
     */
    logLevel?: LogLevel;
    /**
     * If `true`, copies the `error.message` if available to the logger library's
     * message property.
     *
     * If the config option `error.copyMsgOnOnlyError` is enabled, this property
     * can be set to `true` to disable the behavior for this specific log entry.
     */
    copyMsg?: boolean;
}
interface LogLayerErrorConfig<ErrorType> {
    /**
     * A function that takes in an incoming Error type and transforms it into an object.
     * Used in the event that the logging library does not natively support serialization of errors.
     */
    serializer?: ErrorSerializerType<ErrorType>;
    /**
     * Logging libraries may require a specific field name for errors so it knows
     * how to parse them.
     *
     * Default is 'err'.
     */
    fieldName?: string;
    /**
     * If true, always copy error.message if available as a log message along
     * with providing the error data to the logging library.
     *
     * Can be overridden individually by setting `copyMsg: false` in the `onlyError()`
     * call.
     *
     * Default is false.
     */
    copyMsgOnOnlyError?: boolean;
}
interface LogLayerContextConfig {
    /**
     * If specified, will set the context object to a specific field
     * instead of flattening the data alongside the error and message.
     *
     * Default is context data will be flattened.
     */
    fieldName?: string;
}
interface LogLayerMetadataConfig {
    /**
     * If specified, will set the metadata data to a specific field
     * instead of flattening the data alongside the error and message.
     *
     * Default is metadata will be flattened.
     */
    fieldName?: string;
}
interface LogLayerConfig<ErrorType = ErrorDataType> {
    /**
     * The prefix to prepend to all log messages
     */
    prefix?: string;
    /**
     * Set to false to drop all log input and stop sending to the logging
     * library.
     *
     * Can be re-enabled with `enableLogging()`.
     *
     * Default is `true`.
     */
    enabled?: boolean;
    /**
     * If set to true, will also output messages via console logging before
     * sending to the logging library.
     *
     * Useful for troubleshooting a logging library / transports
     * to ensure logs are still being created when the underlying
     * does not print anything.
     */
    consoleDebug?: boolean;
    logger: {
        /**
         * The instance of the logging library to send log data and messages to
         */
        instance: LoggerLibrary;
        /**
         * The instance type of the logging library being used
         */
        type: LoggerType;
    };
    error?: LogLayerErrorConfig<ErrorType>;
    metadata?: LogLayerMetadataConfig;
    context?: LogLayerContextConfig;
    plugins?: Array<LogLayerPlugin>;
    /**
     * If set to true, will not include context data in the log message.
     */
    muteContext?: boolean;
    /**
     * If set to true, will not include metadata data in the log message.
     */
    muteMetadata?: boolean;
}

/**
 * A class that contains methods to specify log metadata and an error and assembles
 * it together to form a data object that can be passed into the logger.
 */
declare class LogBuilder<ExternalLogger extends LoggerLibrary = LoggerLibrary, ErrorType extends Error = ErrorDataType> implements ILogBuilder<ErrorType> {
    private err;
    private metadata;
    private structuredLogger;
    private hasMetadata;
    private pluginManager;
    constructor(structuredLogger: LogLayer<ExternalLogger, ErrorType>);
    /**
     * Adds metadata to the current log entry
     */
    withMetadata(metadata: Record<string, any>): this;
    /**
     * Adds an error to the current log entry
     */
    withError(error: ErrorType): this;
    /**
     * Sends a log message to the logging library under an info log level.
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    info(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the warn log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    warn(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the error log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    error(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the debug log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    debug(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the trace log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    trace(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the fatal log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    fatal(...messages: MessageDataType[]): void;
    /**
     * All logging inputs are dropped and stops sending logs to the logging library.
     */
    disableLogging(): this;
    /**
     * Enable sending logs to the logging library.
     */
    enableLogging(): this;
    private formatLog;
}

declare class PluginManager<Data extends Record<string, any> = Record<string, any>> {
    private idToPlugin;
    private onBeforeDataOut;
    private shouldSendToLogger;
    private onMetadataCalled;
    private onBeforeMessageOut;
    constructor(plugins: Array<LogLayerPlugin>);
    private mapPlugins;
    private indexPlugins;
    hasPlugins(callbackType: PluginCallbackType): boolean;
    countPlugins(callbackType?: PluginCallbackType): number;
    addPlugins(plugins: Array<LogLayerPlugin>): void;
    enablePlugin(id: string): void;
    disablePlugin(id: string): void;
    removePlugin(id: string): void;
    /**
     * Runs plugins that defines onBeforeDataOut.
     */
    runOnBeforeDataOut(params: PluginBeforeDataOutParams): Record<string, any> | undefined;
    /**
     * Runs plugins that define shouldSendToLogger. Any plugin that returns false will prevent the message from being sent to the logger.
     */
    runShouldSendToLogger(params: PluginShouldSendToLoggerParams): boolean;
    /**
     * Runs plugins that define onMetadataCalled.
     */
    runOnMetadataCalled(metadata: Record<string, any>): Record<string, any> | null;
    runOnBeforeMessageOut(params: PluginBeforeMessageOutParams): MessageDataType[];
}

interface FormatLogParams {
    logLevel: LogLevel;
    params?: any[];
    data?: Record<string, any> | null;
}
interface LogLayerInternalConfig<ErrorType> {
    enabled: boolean;
    consoleDebug?: boolean;
    error: LogLayerErrorConfig<ErrorType>;
    metadata: LogLayerMetadataConfig;
    context: LogLayerContextConfig;
    prefix?: string;
    muteContext?: boolean;
    muteMetadata?: boolean;
}
/**
 * Wraps around a logging framework to provide convenience methods that allow
 * developers to programmatically specify their errors and metadata along with
 * a message in a consistent fashion.
 */
declare class LogLayer<ExternalLogger extends LoggerLibrary = LoggerLibrary, ErrorType extends Error = ErrorDataType> implements ILogLayer<ExternalLogger, ErrorType> {
    private loggerInstance;
    private loggerType;
    private context;
    private hasContext;
    private pluginManager;
    _config: LogLayerInternalConfig<ErrorType>;
    constructor({ enabled, logger, error, context, metadata, plugins, consoleDebug, prefix, muteMetadata, muteContext, }: LogLayerConfig<ErrorType>);
    /**
     * Calls child() and sets the prefix to be included with every log message.
     */
    withPrefix(prefix: string): LogLayer<ExternalLogger, ErrorType>;
    /**
     * Appends context data which will be included with
     * every log entry.
     */
    withContext(context: Record<string, any>): LogLayer<ExternalLogger, ErrorType>;
    /**
     * Returns the context used for the logger
     */
    getContext(): Record<string, any>;
    /**
     * Add additional plugins.
     */
    addPlugins(plugins: Array<LogLayerPlugin>): void;
    /**
     * Enables a plugin by id.
     */
    enablePlugin(id: string): void;
    /**
     * Disables a plugin by id.
     */
    disablePlugin(id: string): void;
    /**
     * Removes a plugin by id.
     */
    removePlugin(id: string): void;
    /**
     * Specifies metadata to include with the log message
     */
    withMetadata(metadata: Record<string, any>): LogBuilder<ExternalLogger, ErrorType>;
    /**
     * Specifies an Error to include with the log message
     */
    withError(error: ErrorType): LogBuilder<ExternalLogger, ErrorType>;
    /**
     * Creates a new instance of LogLayer but with the initialization
     * configuration and context copied over.
     */
    child(): LogLayer<ExternalLogger, ErrorType>;
    protected withPluginManager(pluginManager: PluginManager): this;
    /**
     * Logs only the error object without a log message
     */
    errorOnly(error: ErrorType, opts?: ErrorOnlyOpts): void;
    /**
     * Logs only metadata without a log message
     */
    metadataOnly(metadata: Record<string, any>, logLevel?: LogLevel): void;
    /**
     * Sends a log message to the logging library under an info log level.
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    info(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the warn log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    warn(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the error log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    error(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the debug log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    debug(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the trace log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    trace(...messages: MessageDataType[]): void;
    /**
     * Sends a log message to the logging library under the fatal log level
     *
     * The logging library may or may not support multiple message parameters and only
     * the first parameter would be used.
     */
    fatal(...messages: MessageDataType[]): void;
    /**
     * All logging inputs are dropped and stops sending logs to the logging library.
     */
    disableLogging(): this;
    /**
     * Enable sending logs to the logging library.
     */
    enableLogging(): this;
    /**
     * Returns the underlying log instance
     */
    getLoggerInstance(): ExternalLogger;
    /**
     * Disables inclusion of context data in the print
     */
    muteContext(): ILogLayer<ExternalLogger, ErrorType>;
    /**
     * Enables inclusion of context data in the print
     */
    unMuteContext(): ILogLayer<ExternalLogger, ErrorType>;
    /**
     * Disables inclusion of metadata in the print
     */
    muteMetadata(): ILogLayer<ExternalLogger, ErrorType>;
    /**
     * Enables inclusion of metadata in the print
     */
    unMuteMetadata(): ILogLayer<ExternalLogger, ErrorType>;
    private formatContext;
    private formatMetadata;
    _formatMessage(messages?: MessageDataType[]): void;
    _formatLog({ logLevel, params, data }: FormatLogParams): void;
}

declare class MockLogLayer<ErrorType = Error> implements ILogLayer<any, ErrorType> {
    info(...messages: MessageDataType[]): void;
    warn(...messages: MessageDataType[]): void;
    error(...messages: MessageDataType[]): void;
    debug(...messages: MessageDataType[]): void;
    trace(...messages: MessageDataType[]): void;
    fatal(...messages: MessageDataType[]): void;
    getLoggerInstance(): void;
    errorOnly(error: ErrorType, opts?: ErrorOnlyOpts): void;
    metadataOnly(metadata: Record<string, any>, logLevel: LogLevel): void;
    addPlugins(plugins: Array<LogLayerPlugin>): void;
    removePlugin(id: string): void;
    enablePlugin(id: string): void;
    disablePlugin(id: string): void;
    withPrefix(prefix: string): any;
    withContext(context: Record<string, any>): ILogLayer<any, ErrorType>;
    withError(error: ErrorType): ILogBuilder<ErrorType>;
    withMetadata(metadata: Record<string, any>): ILogBuilder<ErrorType>;
    getContext(): Record<string, any>;
    enableLogging(): this;
    disableLogging(): this;
    child(): any;
    muteContext(): this;
    unMuteContext(): this;
    muteMetadata(): this;
    unMuteMetadata(): this;
}

export { type ErrorDataType, type ErrorOnlyOpts, type ErrorSerializerType, type ILogBuilder, type ILogLayer, LogLayer, type LogLayerConfig, type LogLayerContextConfig, type LogLayerErrorConfig, type LogLayerMetadataConfig, type LogLayerPlugin, LogLevel, type LoggerLibrary, LoggerType, type MessageDataType, MockLogLayer, type PluginBeforeDataOutFn, type PluginBeforeDataOutParams, type PluginBeforeMessageOutFn, type PluginBeforeMessageOutParams, PluginCallbackType, type PluginOnMetadataCalledFn, type PluginShouldSendToLoggerFn, type PluginShouldSendToLoggerParams };
