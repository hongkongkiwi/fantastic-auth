// src/types/plugins.types.ts
var PluginCallbackType = /* @__PURE__ */ ((PluginCallbackType2) => {
  PluginCallbackType2["onBeforeDataOut"] = "onBeforeDataOut";
  PluginCallbackType2["shouldSendToLogger"] = "shouldSendToLogger";
  PluginCallbackType2["onMetadataCalled"] = "onMetadataCalled";
  PluginCallbackType2["onBeforeMessageOut"] = "onBeforeMessageOut";
  return PluginCallbackType2;
})(PluginCallbackType || {});

// src/types/common.types.ts
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2["info"] = "info";
  LogLevel2["warn"] = "warn";
  LogLevel2["error"] = "error";
  LogLevel2["debug"] = "debug";
  LogLevel2["trace"] = "trace";
  LogLevel2["fatal"] = "fatal";
  return LogLevel2;
})(LogLevel || {});
var LoggerType = /* @__PURE__ */ ((LoggerType2) => {
  LoggerType2["BUNYAN"] = "bunyan";
  LoggerType2["CONSOLA"] = "consola";
  LoggerType2["CONSOLE"] = "console";
  LoggerType2["ELECTRON_LOG"] = "electronLog";
  LoggerType2["LOG4JS_NODE"] = "log4js-node";
  LoggerType2["PINO"] = "pino";
  LoggerType2["ROARR"] = "roarr";
  LoggerType2["SIGNALE"] = "signale";
  LoggerType2["WINSTON"] = "winston";
  LoggerType2["OTHER"] = "other";
  LoggerType2["DATADOG_BROWSER_LOGS"] = "datadog-browser";
  return LoggerType2;
})(LoggerType || {});

// src/LogBuilder.ts
var LogBuilder = class {
  err;
  metadata;
  structuredLogger;
  hasMetadata;
  pluginManager;
  constructor(structuredLogger) {
    this.err = null;
    this.metadata = {};
    this.structuredLogger = structuredLogger;
    this.hasMetadata = false;
    this.pluginManager = structuredLogger["pluginManager"];
  }
  /**
   * Adds metadata to the current log entry
   */
  withMetadata(metadata) {
    const {
      pluginManager,
      structuredLogger: {
        _config: { consoleDebug }
      }
    } = this;
    let data = metadata;
    if (pluginManager.hasPlugins("onMetadataCalled" /* onMetadataCalled */)) {
      data = pluginManager.runOnMetadataCalled(metadata);
      if (!data) {
        if (consoleDebug) {
          console.debug("[LogLayer] Metadata was dropped due to plugin returning falsy value.");
        }
        return this;
      }
    }
    this.metadata = {
      ...this.metadata,
      ...data
    };
    this.hasMetadata = true;
    return this;
  }
  /**
   * Adds an error to the current log entry
   */
  withError(error) {
    this.err = error;
    return this;
  }
  /**
   * Sends a log message to the logging library under an info log level.
   *
   * The logging library may or may not support multiple message parameters and only
   * the first parameter would be used.
   */
  info(...messages) {
    this.structuredLogger._formatMessage(messages);
    this.formatLog("info" /* info */, messages);
  }
  /**
   * Sends a log message to the logging library under the warn log level
   *
   * The logging library may or may not support multiple message parameters and only
   * the first parameter would be used.
   */
  warn(...messages) {
    this.structuredLogger._formatMessage(messages);
    this.formatLog("warn" /* warn */, messages);
  }
  /**
   * Sends a log message to the logging library under the error log level
   *
   * The logging library may or may not support multiple message parameters and only
   * the first parameter would be used.
   */
  error(...messages) {
    this.structuredLogger._formatMessage(messages);
    this.formatLog("error" /* error */, messages);
  }
  /**
   * Sends a log message to the logging library under the debug log level
   *
   * The logging library may or may not support multiple message parameters and only
   * the first parameter would be used.
   */
  debug(...messages) {
    this.structuredLogger._formatMessage(messages);
    this.formatLog("debug" /* debug */, messages);
  }
  /**
   * Sends a log message to the logging library under the trace log level
   *
   * The logging library may or may not support multiple message parameters and only
   * the first parameter would be used.
   */
  trace(...messages) {
    this.structuredLogger._formatMessage(messages);
    this.formatLog("trace" /* trace */, messages);
  }
  /**
   * Sends a log message to the logging library under the fatal log level
   *
   * The logging library may or may not support multiple message parameters and only
   * the first parameter would be used.
   */
  fatal(...messages) {
    this.structuredLogger._formatMessage(messages);
    this.formatLog("fatal" /* fatal */, messages);
  }
  /**
   * All logging inputs are dropped and stops sending logs to the logging library.
   */
  disableLogging() {
    this.structuredLogger._config.enabled = false;
    return this;
  }
  /**
   * Enable sending logs to the logging library.
   */
  enableLogging() {
    this.structuredLogger._config.enabled = true;
    return this;
  }
  formatLog(logLevel, params) {
    const { error: errConfig, muteMetadata } = this.structuredLogger._config;
    const hasData = (muteMetadata ? false : this.hasMetadata) || !!this.err;
    const data = {
      ...this.metadata
    };
    if (this.err && errConfig.fieldName) {
      data[errConfig.fieldName] = errConfig.serializer ? errConfig.serializer(this.err) : this.err;
    }
    this.structuredLogger._formatLog({ logLevel, params, data: hasData ? data : null });
  }
};

// src/plugins/PluginManager.ts
var CALLBACK_LIST = [
  "onBeforeDataOut" /* onBeforeDataOut */,
  "onMetadataCalled" /* onMetadataCalled */,
  "shouldSendToLogger" /* shouldSendToLogger */,
  "onBeforeMessageOut" /* onBeforeMessageOut */
];
var PluginManager = class {
  idToPlugin;
  // Indexes for each plugin type
  onBeforeDataOut = [];
  shouldSendToLogger = [];
  onMetadataCalled = [];
  onBeforeMessageOut = [];
  constructor(plugins) {
    this.idToPlugin = {};
    this.mapPlugins(plugins);
    this.indexPlugins();
  }
  mapPlugins(plugins) {
    for (const plugin of plugins) {
      if (!plugin.id) {
        plugin.id = (/* @__PURE__ */ new Date()).getTime().toString() + Math.random().toString();
      }
      if (this.idToPlugin[plugin.id]) {
        throw new Error(`[LogLayer] Plugin with id ${plugin.id} already exists.`);
      }
      plugin["registeredAt"] = (/* @__PURE__ */ new Date()).getTime();
      this.idToPlugin[plugin.id] = plugin;
    }
  }
  indexPlugins() {
    this.onBeforeDataOut = [];
    this.shouldSendToLogger = [];
    this.onMetadataCalled = [];
    this.onBeforeMessageOut = [];
    const pluginList = Object.values(this.idToPlugin).sort((a, b) => a.registeredAt - b.registeredAt);
    for (const plugin of pluginList) {
      if (plugin.disabled) {
        return;
      }
      for (const callback of CALLBACK_LIST) {
        if (plugin[callback] && plugin.id) {
          this[callback].push(plugin.id);
        }
      }
    }
  }
  hasPlugins(callbackType) {
    return this[callbackType].length > 0;
  }
  countPlugins(callbackType) {
    if (callbackType) {
      return this[callbackType].length;
    }
    return Object.keys(this.idToPlugin).length;
  }
  addPlugins(plugins) {
    this.mapPlugins(plugins);
    this.indexPlugins();
  }
  enablePlugin(id) {
    const plugin = this.idToPlugin[id];
    if (plugin) {
      plugin.disabled = false;
    }
    this.indexPlugins();
  }
  disablePlugin(id) {
    const plugin = this.idToPlugin[id];
    if (plugin) {
      plugin.disabled = true;
    }
    this.indexPlugins();
  }
  removePlugin(id) {
    delete this.idToPlugin[id];
    this.indexPlugins();
  }
  /**
   * Runs plugins that defines onBeforeDataOut.
   */
  runOnBeforeDataOut(params) {
    const initialData = { ...params };
    for (const pluginId of this.onBeforeDataOut) {
      const plugin = this.idToPlugin[pluginId];
      if (plugin.onBeforeDataOut) {
        const result = plugin.onBeforeDataOut({
          data: initialData.data,
          logLevel: initialData.logLevel
        });
        if (result) {
          if (!initialData.data) {
            initialData.data = {};
          }
          Object.assign(initialData.data, result);
        }
      }
    }
    return initialData.data;
  }
  /**
   * Runs plugins that define shouldSendToLogger. Any plugin that returns false will prevent the message from being sent to the logger.
   */
  runShouldSendToLogger(params) {
    return !this.shouldSendToLogger.some((pluginId) => {
      const plugin = this.idToPlugin[pluginId];
      return !plugin.shouldSendToLogger(params);
    });
  }
  /**
   * Runs plugins that define onMetadataCalled.
   */
  runOnMetadataCalled(metadata) {
    let data = {
      ...metadata
    };
    for (const pluginId of this.onMetadataCalled) {
      const plugin = this.idToPlugin[pluginId];
      const result = plugin.onMetadataCalled(data);
      if (result) {
        data = result;
      } else {
        return null;
      }
    }
    return data;
  }
  runOnBeforeMessageOut(params) {
    let messages = [...params.messages];
    for (const pluginId of this.onBeforeMessageOut) {
      const plugin = this.idToPlugin[pluginId];
      const result = plugin.onBeforeMessageOut({
        messages,
        logLevel: params.logLevel
      });
      if (result) {
        messages = result;
      }
    }
    return messages;
  }
};

// src/LogLayer.ts
var LogLayer = class _LogLayer {
  loggerInstance;
  loggerType;
  context;
  hasContext;
  pluginManager;
  _config;
  constructor({
    enabled,
    logger,
    error,
    context,
    metadata,
    plugins,
    consoleDebug,
    prefix,
    muteMetadata,
    muteContext
  }) {
    this.loggerInstance = logger.instance;
    this.loggerType = logger?.type || "other" /* OTHER */;
    this.context = {};
    this.hasContext = false;
    this._config = {
      enabled: enabled ?? true,
      consoleDebug: consoleDebug ?? false,
      error: error || {},
      context: context || {},
      metadata: metadata || {},
      prefix: prefix || "",
      muteContext,
      muteMetadata
    };
    this.pluginManager = new PluginManager(plugins || []);
    if (!this._config.error.fieldName) {
      this._config.error.fieldName = "err";
    }
    if (!this._config.error.copyMsgOnOnlyError) {
      this._config.error.copyMsgOnOnlyError = false;
    }
  }
  /**
   * Calls child() and sets the prefix to be included with every log message.
   */
  withPrefix(prefix) {
    const logger = this.child();
    logger._config.prefix = prefix;
    return logger;
  }
  /**
   * Appends context data which will be included with
   * every log entry.
   */
  withContext(context) {
    this.context = {
      ...this.context,
      ...context
    };
    this.hasContext = true;
    return this;
  }
  /**
   * Returns the context used for the logger
   */
  getContext() {
    return this.context;
  }
  /**
   * Add additional plugins.
   */
  addPlugins(plugins) {
    this.pluginManager.addPlugins(plugins);
  }
  /**
   * Enables a plugin by id.
   */
  enablePlugin(id) {
    this.pluginManager.enablePlugin(id);
  }
  /**
   * Disables a plugin by id.
   */
  disablePlugin(id) {
    this.pluginManager.disablePlugin(id);
  }
  /**
   * Removes a plugin by id.
   */
  removePlugin(id) {
    this.pluginManager.removePlugin(id);
  }
  /**
   * Specifies metadata to include with the log message
   */
  withMetadata(metadata) {
    return new LogBuilder(this).withMetadata(metadata);
  }
  /**
   * Specifies an Error to include with the log message
   */
  withError(error) {
    return new LogBuilder(this).withError(error);
  }
  /**
   * Creates a new instance of LogLayer but with the initialization
   * configuration and context copied over.
   */
  child() {
    if (this.hasContext) {
      return new _LogLayer({
        ...this._config,
        logger: {
          instance: this.loggerInstance,
          type: this.loggerType
        }
      }).withContext({
        ...this.context
      }).withPluginManager(this.pluginManager);
    }
    return new _LogLayer({
      ...this._config,
      logger: {
        instance: this.loggerInstance,
        type: this.loggerType
      }
    }).withPluginManager(this.pluginManager);
  }
  withPluginManager(pluginManager) {
    this.pluginManager = pluginManager;
    return this;
  }
  /**
   * Logs only the error object without a log message
   */
  errorOnly(error, opts) {
    const { error: errConfig } = this._config;
    const formatLogConf = {
      logLevel: opts?.logLevel || "error" /* error */,
      data: {
        [errConfig.fieldName]: errConfig.serializer ? errConfig.serializer(error) : error
      }
    };
    if (this.loggerType === "roarr" /* ROARR */) {
      formatLogConf.params = [""];
    }
    if ((errConfig.copyMsgOnOnlyError && opts?.copyMsg !== false || opts?.copyMsg === true) && error.message) {
      formatLogConf.params = [error.message];
    }
    this._formatLog(formatLogConf);
  }
  /**
   * Logs only metadata without a log message
   */
  metadataOnly(metadata, logLevel = "info" /* info */) {
    const { muteMetadata, consoleDebug } = this._config;
    if (muteMetadata) {
      return;
    }
    let data = metadata;
    if (this.pluginManager.hasPlugins("onMetadataCalled" /* onMetadataCalled */)) {
      data = this.pluginManager.runOnMetadataCalled(metadata);
      if (!data) {
        if (consoleDebug) {
          console.debug("[LogLayer] Metadata was dropped due to plugin returning falsy value.");
        }
        return;
      }
    }
    const config = {
      logLevel,
      data
    };
    if (this.loggerType === "roarr" /* ROARR */) {
      config.params = [""];
    }
    this._formatLog(config);
  }
  /**
   * Sends a log message to the logging library under an info log level.
   *
   * The logging library may or may not support multiple message parameters and only
   * the first parameter would be used.
   */
  info(...messages) {
    this._formatMessage(messages);
    this._formatLog({ logLevel: "info" /* info */, params: messages });
  }
  /**
   * Sends a log message to the logging library under the warn log level
   *
   * The logging library may or may not support multiple message parameters and only
   * the first parameter would be used.
   */
  warn(...messages) {
    this._formatMessage(messages);
    this._formatLog({ logLevel: "warn" /* warn */, params: messages });
  }
  /**
   * Sends a log message to the logging library under the error log level
   *
   * The logging library may or may not support multiple message parameters and only
   * the first parameter would be used.
   */
  error(...messages) {
    this._formatMessage(messages);
    this._formatLog({ logLevel: "error" /* error */, params: messages });
  }
  /**
   * Sends a log message to the logging library under the debug log level
   *
   * The logging library may or may not support multiple message parameters and only
   * the first parameter would be used.
   */
  debug(...messages) {
    this._formatMessage(messages);
    this._formatLog({ logLevel: "debug" /* debug */, params: messages });
  }
  /**
   * Sends a log message to the logging library under the trace log level
   *
   * The logging library may or may not support multiple message parameters and only
   * the first parameter would be used.
   */
  trace(...messages) {
    this._formatMessage(messages);
    this._formatLog({ logLevel: "trace" /* trace */, params: messages });
  }
  /**
   * Sends a log message to the logging library under the fatal log level
   *
   * The logging library may or may not support multiple message parameters and only
   * the first parameter would be used.
   */
  fatal(...messages) {
    this._formatMessage(messages);
    this._formatLog({ logLevel: "fatal" /* fatal */, params: messages });
  }
  /**
   * All logging inputs are dropped and stops sending logs to the logging library.
   */
  disableLogging() {
    this._config.enabled = false;
    return this;
  }
  /**
   * Enable sending logs to the logging library.
   */
  enableLogging() {
    this._config.enabled = true;
    return this;
  }
  /**
   * Returns the underlying log instance
   */
  getLoggerInstance() {
    return this.loggerInstance;
  }
  /**
   * Disables inclusion of context data in the print
   */
  muteContext() {
    this._config.muteContext = true;
    return this;
  }
  /**
   * Enables inclusion of context data in the print
   */
  unMuteContext() {
    this._config.muteContext = false;
    return this;
  }
  /**
   * Disables inclusion of metadata in the print
   */
  muteMetadata() {
    this._config.muteMetadata = true;
    return this;
  }
  /**
   * Enables inclusion of metadata in the print
   */
  unMuteMetadata() {
    this._config.muteMetadata = false;
    return this;
  }
  formatContext() {
    const { context: contextCfg, muteContext } = this._config;
    if (this.hasContext && !muteContext) {
      if (contextCfg.fieldName) {
        return {
          [contextCfg.fieldName]: {
            ...this.context
          }
        };
      }
      return {
        ...this.context
      };
    }
    return {};
  }
  formatMetadata(data = null) {
    const { metadata: metadataCfg, muteMetadata } = this._config;
    if (data && !muteMetadata) {
      if (metadataCfg.fieldName) {
        return {
          [metadataCfg.fieldName]: {
            ...data
          }
        };
      }
      return {
        ...data
      };
    }
    return {};
  }
  _formatMessage(messages = []) {
    const { prefix } = this._config;
    if (prefix && typeof messages[0] === "string") {
      messages[0] = `${prefix} ${messages[0]}`;
    }
  }
  _formatLog({ logLevel, params = [], data = null }) {
    const { enabled, muteContext, context, metadata, consoleDebug } = this._config;
    if (!enabled) {
      return;
    }
    const hasObjData = !!data || (muteContext ? false : this.hasContext);
    let d = {};
    if (hasObjData) {
      if (context.fieldName && context.fieldName === metadata.fieldName) {
        const contextData = this.formatContext()[context.fieldName];
        const updatedMetadata = this.formatMetadata(data)[metadata.fieldName];
        d = {
          [context.fieldName]: {
            ...contextData,
            ...updatedMetadata
          }
        };
      } else {
        d = {
          ...this.formatContext(),
          ...this.formatMetadata(data)
        };
      }
    }
    if (this.pluginManager.hasPlugins("onBeforeDataOut" /* onBeforeDataOut */)) {
      d = this.pluginManager.runOnBeforeDataOut({
        data: hasObjData ? d : void 0,
        logLevel
      });
    }
    if (this.pluginManager.hasPlugins("onBeforeMessageOut" /* onBeforeMessageOut */)) {
      params = this.pluginManager.runOnBeforeMessageOut({
        messages: [...params],
        logLevel
      });
    }
    if (this.pluginManager.hasPlugins("shouldSendToLogger" /* shouldSendToLogger */)) {
      const shouldSend = this.pluginManager.runShouldSendToLogger({
        messages: [...params],
        data: hasObjData ? d : void 0,
        logLevel
      });
      if (!shouldSend) {
        return;
      }
    }
    if (d && hasObjData) {
      switch (this.loggerType) {
        case "consola" /* CONSOLA */:
        case "electronLog" /* ELECTRON_LOG */:
        case "log4js-node" /* LOG4JS_NODE */:
        case "signale" /* SIGNALE */:
        case "winston" /* WINSTON */:
        case "datadog-browser" /* DATADOG_BROWSER_LOGS */:
          params.push(d);
          break;
        default:
          params.unshift(d);
      }
    }
    switch (logLevel) {
      case "info" /* info */:
        if (consoleDebug) {
          console.info(...params);
        }
        this.loggerInstance.info(...params);
        break;
      case "warn" /* warn */:
        if (consoleDebug) {
          console.warn(...params);
        }
        this.loggerInstance.warn(...params);
        break;
      case "error" /* error */:
        if (consoleDebug) {
          console.error(...params);
        }
        this.loggerInstance.error(...params);
        break;
      case "trace" /* trace */:
        if (consoleDebug) {
          console.debug(...params);
        }
        if (this.loggerType === "winston" /* WINSTON */ || this.loggerType === "signale" /* SIGNALE */ || this.loggerType === "datadog-browser" /* DATADOG_BROWSER_LOGS */) {
          this.loggerInstance.debug(...params);
        } else if (this.loggerInstance.trace) {
          this.loggerInstance.trace(...params);
        } else {
          this.loggerInstance.debug(...params);
        }
        break;
      case "debug" /* debug */:
        if (consoleDebug) {
          console.debug(...params);
        }
        this.loggerInstance.debug(...params);
        break;
      case "fatal" /* fatal */:
        if (consoleDebug) {
          console.debug(...params);
        }
        if (this.loggerType === "winston" /* WINSTON */ || this.loggerType === "electronLog" /* ELECTRON_LOG */ || this.loggerType === "console" /* CONSOLE */ || this.loggerType === "datadog-browser" /* DATADOG_BROWSER_LOGS */) {
          this.loggerInstance.error(...params);
        } else if (this.loggerInstance.fatal) {
          this.loggerInstance.fatal(...params);
        } else {
          this.loggerInstance.error(...params);
        }
        break;
      default:
        if (consoleDebug) {
          console.log(...params);
        }
        this.loggerInstance[logLevel](...params);
    }
  }
};

// src/MockLogBuilder.ts
var MockLogBuilder = class {
  debug(...messages) {
  }
  error(...messages) {
  }
  info(...messages) {
  }
  trace(...messages) {
  }
  warn(...messages) {
  }
  fatal(...messages) {
  }
  enableLogging() {
    return this;
  }
  disableLogging() {
    return this;
  }
  withMetadata(metadata) {
    return this;
  }
  withError(error) {
    return this;
  }
};

// src/MockLogLayer.ts
var MockLogLayer = class _MockLogLayer {
  info(...messages) {
  }
  warn(...messages) {
  }
  error(...messages) {
  }
  debug(...messages) {
  }
  trace(...messages) {
  }
  fatal(...messages) {
  }
  getLoggerInstance() {
  }
  errorOnly(error, opts) {
  }
  metadataOnly(metadata, logLevel) {
  }
  addPlugins(plugins) {
  }
  removePlugin(id) {
  }
  enablePlugin(id) {
  }
  disablePlugin(id) {
  }
  withPrefix(prefix) {
    return new _MockLogLayer();
  }
  withContext(context) {
    return this;
  }
  withError(error) {
    return new MockLogBuilder();
  }
  withMetadata(metadata) {
    return new MockLogBuilder();
  }
  getContext() {
    return {};
  }
  enableLogging() {
    return this;
  }
  disableLogging() {
    return this;
  }
  child() {
    return new _MockLogLayer();
  }
  muteContext() {
    return this;
  }
  unMuteContext() {
    return this;
  }
  muteMetadata() {
    return this;
  }
  unMuteMetadata() {
    return this;
  }
};
export {
  LogLayer,
  LogLevel,
  LoggerType,
  MockLogLayer,
  PluginCallbackType
};
//# sourceMappingURL=index.mjs.map