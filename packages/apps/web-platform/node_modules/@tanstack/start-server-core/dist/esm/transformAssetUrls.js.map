{"version":3,"file":"transformAssetUrls.js","sources":["../../src/transformAssetUrls.ts"],"sourcesContent":["import { rootRouteId } from '@tanstack/router-core'\n\nimport type {\n  Awaitable,\n  Manifest,\n  RouterManagedTag,\n} from '@tanstack/router-core'\n\nexport type AssetUrlType = 'modulepreload' | 'stylesheet' | 'clientEntry'\n\nexport interface TransformAssetUrlsContext {\n  url: string\n  type: AssetUrlType\n}\n\nexport type TransformAssetUrlsFn = (\n  context: TransformAssetUrlsContext,\n) => Awaitable<string>\n\nexport type CreateTransformAssetUrlsContext =\n  | {\n      /** True when the server is computing the cached manifest during startup warmup. */\n      warmup: true\n    }\n  | {\n      /**\n       * The current Request.\n       *\n       * Only available during request handling (i.e. when `warmup: false`).\n       */\n      request: Request\n      /** False when transforming URLs as part of request handling. */\n      warmup: false\n    }\n\n/**\n * Async factory that runs once per manifest computation and returns the\n * per-asset transform.\n */\nexport type CreateTransformAssetUrlsFn = (\n  ctx: CreateTransformAssetUrlsContext,\n) => Awaitable<TransformAssetUrlsFn>\n\ntype TransformAssetUrlsOptionsBase = {\n  /**\n   * Whether to cache the transformed manifest after the first request.\n   *\n   * When `true` (default), the transform runs once on the first request and\n   * the resulting manifest is reused for all subsequent requests in production.\n   *\n   * Set to `false` for per-request transforms (e.g. geo-routing to different\n   * CDNs based on request headers).\n   *\n   * @default true\n   */\n  cache?: boolean\n\n  /**\n   * When `true`, warms up the cached transformed manifest in the background when\n   * the server starts (production only).\n   *\n   * This can reduce latency for the first request when `cache` is `true`.\n   * Has no effect when `cache: false` (per-request transforms) or in dev mode.\n   *\n   * @default false\n   */\n  warmup?: boolean\n}\n\nexport type TransformAssetUrlsOptions =\n  | (TransformAssetUrlsOptionsBase & {\n      /**\n       * The transform to apply to asset URLs. Can be a string prefix or a callback.\n       *\n       * **String** — prepended to every asset URL.\n       * **Callback** — receives `{ url, type }` and returns a new URL.\n       */\n      transform: string | TransformAssetUrlsFn\n      createTransform?: never\n    })\n  | (TransformAssetUrlsOptionsBase & {\n      /**\n       * Create a per-asset transform function.\n       *\n       * This factory runs once per manifest computation (per request when\n       * `cache: false`, or once per server when `cache: true`). It can do async\n       * setup work (fetch config, read from a KV, etc.) and return a fast\n       * per-asset transformer.\n       */\n      createTransform: CreateTransformAssetUrlsFn\n      transform?: never\n    })\n\nexport type TransformAssetUrls =\n  | string\n  | TransformAssetUrlsFn\n  | TransformAssetUrlsOptions\n\nexport type ResolvedTransformAssetUrlsConfig =\n  | {\n      type: 'transform'\n      transformFn: TransformAssetUrlsFn\n      cache: boolean\n    }\n  | {\n      type: 'createTransform'\n      createTransform: CreateTransformAssetUrlsFn\n      cache: boolean\n    }\n\n/**\n * Resolves a TransformAssetUrls value (string prefix, callback, or options\n * object) into a concrete transform function and cache flag.\n */\nexport function resolveTransformConfig(\n  transform: TransformAssetUrls,\n): ResolvedTransformAssetUrlsConfig {\n  // String shorthand\n  if (typeof transform === 'string') {\n    const prefix = transform\n    return {\n      type: 'transform',\n      transformFn: ({ url }) => `${prefix}${url}`,\n      cache: true,\n    }\n  }\n\n  // Callback shorthand\n  if (typeof transform === 'function') {\n    return {\n      type: 'transform',\n      transformFn: transform,\n      cache: true,\n    }\n  }\n\n  // Options object\n  if ('createTransform' in transform && transform.createTransform) {\n    return {\n      type: 'createTransform',\n      createTransform: transform.createTransform,\n      cache: transform.cache !== false,\n    }\n  }\n\n  const transformFn =\n    typeof transform.transform === 'string'\n      ? ((({ url }: TransformAssetUrlsContext) =>\n          `${transform.transform}${url}`) as TransformAssetUrlsFn)\n      : transform.transform\n\n  return {\n    type: 'transform',\n    transformFn,\n    cache: transform.cache !== false,\n  }\n}\n\nexport interface StartManifestWithClientEntry {\n  manifest: Manifest\n  clientEntry: string\n  /** Script content prepended before the client entry import (dev only) */\n  injectedHeadScripts?: string\n}\n\n/**\n * Builds the client entry `<script>` tag from a (possibly transformed) client\n * entry URL and optional injected head scripts.\n */\nexport function buildClientEntryScriptTag(\n  clientEntry: string,\n  injectedHeadScripts?: string,\n): RouterManagedTag {\n  const clientEntryLiteral = JSON.stringify(clientEntry)\n  let script = `import(${clientEntryLiteral})`\n  if (injectedHeadScripts) {\n    script = `${injectedHeadScripts};${script}`\n  }\n  return {\n    tag: 'script',\n    attrs: {\n      type: 'module',\n      async: true,\n    },\n    children: script,\n  }\n}\n\n/**\n * Applies a URL transform to every asset URL in the manifest and returns a\n * new manifest with a client entry script tag appended to the root route's\n * assets.\n *\n * The source manifest is deep-cloned so the cached original is never mutated.\n */\nexport function transformManifestUrls(\n  source: StartManifestWithClientEntry,\n  transformFn: TransformAssetUrlsFn,\n  opts?: {\n    /** When true, clone the source manifest before mutating it. */\n    clone?: boolean\n  },\n): Promise<Manifest> {\n  return (async () => {\n    const manifest = opts?.clone\n      ? structuredClone(source.manifest)\n      : source.manifest\n\n    for (const route of Object.values(manifest.routes)) {\n      // Transform preload URLs (modulepreload)\n      if (route.preloads) {\n        route.preloads = await Promise.all(\n          route.preloads.map((url) =>\n            Promise.resolve(transformFn({ url, type: 'modulepreload' })),\n          ),\n        )\n      }\n\n      // Transform asset tag URLs\n      if (route.assets) {\n        for (const asset of route.assets) {\n          if (asset.tag === 'link' && asset.attrs?.href) {\n            asset.attrs.href = await Promise.resolve(\n              transformFn({\n                url: asset.attrs.href,\n                type: 'stylesheet',\n              }),\n            )\n          }\n        }\n      }\n    }\n\n    // Transform and append the client entry script tag\n    const transformedClientEntry = await Promise.resolve(\n      transformFn({\n        url: source.clientEntry,\n        type: 'clientEntry',\n      }),\n    )\n\n    const rootRoute = manifest.routes[rootRouteId]\n    if (rootRoute) {\n      rootRoute.assets = rootRoute.assets || []\n      rootRoute.assets.push(\n        buildClientEntryScriptTag(\n          transformedClientEntry,\n          source.injectedHeadScripts,\n        ),\n      )\n    }\n\n    return manifest\n  })()\n}\n\n/**\n * Builds a final Manifest from a StartManifestWithClientEntry without any\n * URL transforms. Used when no transformAssetUrls option is provided.\n *\n * Returns a new manifest object so the cached base manifest is never mutated.\n */\nexport function buildManifestWithClientEntry(\n  source: StartManifestWithClientEntry,\n): Manifest {\n  const scriptTag = buildClientEntryScriptTag(\n    source.clientEntry,\n    source.injectedHeadScripts,\n  )\n\n  const baseRootRoute = source.manifest.routes[rootRouteId]\n  const routes = {\n    ...source.manifest.routes,\n    ...(baseRootRoute\n      ? {\n          [rootRouteId]: {\n            ...baseRootRoute,\n            assets: [...(baseRootRoute.assets || []), scriptTag],\n          },\n        }\n      : {}),\n  }\n\n  return { routes }\n}\n"],"names":[],"mappings":"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"}